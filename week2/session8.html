<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Session 8 | M3 - Introduction to Vue.js</title>

		<meta name="description" content="M3 - Introduction to Vue.js | Session 8">
		<meta name="author" content="Dani Nebot">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/harbour.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>

	<body>
		<div class="header">
			<a href="../index.html">
				<svg class="harbour-logo" height="26" viewBox="0 0 270 26" width="270"><path d="m269.359 21.241v3.536h-15.158v-23.573h15.125v3.538h-11.084v6.533h9.5v3.366h-9.5v6.602zm-28.902 4.04c-5.83 0-9.164-3.098-9.164-8.484v-7.609c0-5.387 3.334-8.487 9.164-8.487 2.492 0 4.547.674 6.197 2.056 1.65 1.378 2.492 3.4 2.492 6.094v.337h-4.041v-.337c0-1.449-.474-2.559-1.449-3.3-.977-.776-2.055-1.146-3.234-1.146-3.402 0-5.086 1.651-5.086 4.514v8.147c0 2.86 1.684 4.514 5.086 4.514 1.18 0 2.258-.371 3.234-1.112.977-.774 1.449-1.887 1.449-3.336v-.335h4.041v.335c0 2.696-.842 4.718-2.492 6.097-1.65 1.38-3.705 2.052-6.197 2.052zm-18.26-6.329h-8.893l-2.121 5.825h-3.74v-1.347l8.422-22.227h3.975l8.422 22.227v1.348h-3.975zm-4.412-12.357-3.268 8.991h6.469zm-17.484 9.093h-6.164v9.09h-4.043v-23.574h10.207c4.143 0 6.635 2.799 6.635 7.242 0 4.446-2.493 7.242-6.635 7.242zm-.707-10.946h-5.457v7.409h5.457c1.854 0 3.234-1.314 3.234-3.705 0-2.389-1.381-3.704-3.234-3.704zm-22.84 6.297.471.168c1.281.438 2.293.843 3.033 1.18.773.335 1.549.775 2.393 1.345 1.648 1.11 2.39 2.593 2.39 4.58 0 4.142-3.164 6.97-8.924 6.97-2.63 0-4.818-.706-6.57-2.087-1.717-1.413-2.594-3.436-2.594-6.062h4.043c0 1.112.303 1.989.875 2.696 1.213 1.381 2.729 1.752 4.479 1.752 2.83 0 4.414-1.28 4.414-3.065 0-.842-.371-1.48-1.111-1.92-.741-.471-2.09-1.078-4.043-1.816l-.305-.102-.539-.203c-2.559-.977-4.41-1.919-5.522-2.829-1.113-.943-1.649-2.29-1.649-4.073 0-2.055.741-3.738 2.258-4.985 1.514-1.246 3.604-1.886 6.229-1.886 5.287 0 8.758 2.526 8.758 7.948h-4.041c0-2.964-2.021-4.244-4.75-4.244-2.661 0-4.379 1.212-4.379 2.862 0 .91.336 1.617 1.043 2.054.705.44 2.053 1.009 4.041 1.717zm-30.959 4.68h-4.648v9.059h-4.043v-23.574h10.14c4.582 0 7.108 2.663 7.108 7.242 0 3.132-1.416 5.623-4.145 6.803l4.412 8.183v1.346h-3.973zm4.445-7.205c0-2.527-1.246-3.772-3.738-3.772h-5.355v7.544h5.355c2.492 0 3.738-1.248 3.738-3.772zm-27.791 16.767c-2.729 0-4.916-.706-6.535-2.154-1.582-1.445-2.393-3.466-2.393-6.025v-15.896h4.044v16.096c0 2.458 1.751 4.278 4.884 4.278s4.885-1.82 4.885-4.278v-16.096h4.041v15.896c0 2.561-.808 4.58-2.424 6.025-1.584 1.448-3.773 2.154-6.502 2.154zm-23.242.001c-5.693 0-9.266-3.198-9.266-8.485v-7.61c0-5.287 3.572-8.486 9.266-8.486s9.262 3.199 9.262 8.486v7.61c0 5.287-3.569 8.485-9.262 8.485zm5.221-16.297c0-2.661-1.854-4.581-5.221-4.581-3.37 0-5.223 1.919-5.223 4.581v8.015c0 2.661 1.853 4.58 5.223 4.58 3.367 0 5.221-1.919 5.221-4.58zm-25.266 15.792h-10.847v-23.573h9.939c4.209 0 6.736 2.157 6.736 6.333 0 2.391-.943 4.042-2.828 5.017 2.491.91 3.737 2.795 3.737 5.692 0 4.274-2.459 6.531-6.737 6.531zm-1.582-20.035h-5.222v6.566h5.222c2.222 0 3.334-1.11 3.334-3.3s-1.112-3.266-3.334-3.266zm.908 9.935h-6.13v6.564h6.13c2.258 0 3.369-1.078 3.369-3.232 0-2.222-1.111-3.332-3.369-3.332zm-23.715 1.042h-4.648v9.059h-4.043v-23.574h10.139c4.582 0 7.108 2.663 7.108 7.242 0 3.132-1.415 5.623-4.144 6.803l4.414 8.183v1.346h-3.976zm4.447-7.205c0-2.527-1.247-3.772-3.738-3.772h-5.356v7.544h5.356c2.491 0 3.738-1.248 3.738-3.772zm-22.907 10.438h-8.893l-2.122 5.825h-3.74v-1.347l8.422-22.226h3.975l8.421 22.228v1.346h-3.975zm-4.413-12.357-3.267 8.991h6.467zm-18.09 8.148h-9.77v10.034h-4.04v-23.573h4.041v10.002h9.77v-10.002h4.041v23.573h-4.042z"></path><circle cx="161.555" cy="24.745" r="1.256"></circle></svg>
			</a>
		</div>

		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
					<h3>M3 - Introduction to Vue.js</h3>
					<p>
						<a href="https://harbour.space/faculty/Dani-Nebot">Dani Nebot</a>
					</p>
				</section>

				<section>
					<h3>Session 8</h3>
					<p><small>Testing Vue Components</small></p>
				</section>

        <section>
					<section>
            <h3>What is Unit Testing</h3>

            <p>Simplest definition: A Unit Test verifies whether a <b>small and isolated</b> piece of the codebase
            (called a <em>unit</em>) behaves as the developer intended.</p>

						<p>In FE, we can consider <b>Components</b> that follow FIRST principles as <em>units</em>.</p>
						<p><b>Functions</b> exposed by JavaScript libraries or services can (and should) also be tested as <em>units</em>.</p>
          </section>

          <section data-markdown>
            #### How do Unit Tests look like?


            ```
// A Unit tests consists of 3 phases: arrange, act and assert.

import { getDayOfTheWeek } from './utils/dates'

describe('getDayOfTheWeek', () => {
	test('returns day name from date in "DD MM YYYY" format', () => {
		const testDate = '21 Nov 2022' // arrange
		const result = getDayOfTheWeek(testDate) // act
		expect(result).toBe('Monday') // asert
	})
})
              ```
          </section>
          <section data-markdown>
            ### Benefits of Unit Tests
              - Bug catched and squashed during development ü™≤
              - Higher code quality üìà
              - Better application architecture üîù
              - Bonus: they can act as documentation üìÑ
          </section>

          <section data-markdown>
            ### Testing libraries

            There are [**several testing libraries, frameworks, test runners**](https://2021.stateofjs.com/en-US/libraries/testing/), etc...
						for JavaScript in the FE (and/or BE)
          </section>
					<section data-markdown>
						#### Vitest and Vue Test Utils
						In this course, we are going to use [**Vitest**](https://vitest.dev/) as our test runner, and [**Vue Test Utils**](https://test-utils.vuejs.org/) as our testing suite library for Unit Testing our Vue Components
					</section>

        </section>

				<section>
					<section data-markdown="">
            ### Vitest

            But why?

            - Drop-in compatibility with Vite
            - It's blazing fast!
            - Chai and Jest compatibile syntax / API
            - Awesome GUI
            - ... [And more](https://vitest.dev/guide/features.html)
          </section>

					<section data-markdown="">
						#### What is a test runner?

						A test runner is a tool that is used to run or execute tests and display or export the results.

						It is usually configured to scan automatically for test files in the project folders, and run them:

						```
						// inside my project's package.json file "scripts"
						"test:ui": "vitest --ui",
						```

					</section>
          <section data-markdown="">
            ### How do Vitest tests look like?

            ![](../assets/vitest.png)

            [Let's see it in action!](https://vitest.new/)
          </section>
				</section>

        <section>
					<section data-markdown="">
						### Vue Test Utils

						Vue Test Utils (VTU) is a set of utility functions aimed to simplify unit testing Vue.js components.

						The aim is to provide some utilities to *mount* and *interact* with Vue components in an isolated manner.

						**Vue Test Utils v2** is compatible with Vue 3
					</section>

					<section data-markdown="">
						#### Workflow in Component Unit Tests:

						- Use `mount()` to render a component.
						- Query the DOM using `get()`, `findAll()`, etc
						- Use helpers `trigger()` and `setValue()` to simulate user input.
						- Updating the DOM is an *asynchronous operation*, so make sure to use `async` and `await`.
					</section>

					<section data-markdown="">
						#### Anatomy of a VTU Unit test

						```
						import { mount } from '@vue/test-utils'

						const MessageComponent = {
							template: '<p>{{ msg }}</p>',
							props: ['msg']
						}

						test('displays message', () => {
							const wrapper = mount(MessageComponent, {
								props: { msg: 'Hello world' }
							})

							// Assert the rendered text of the component
							expect(wrapper.text()).toContain('Hello world')
						})
						```

					</section>

					<section data-markdown="">
						#### How to write tests

						Think in terms of **inputs and outputs** from a user perspective. This is what you should be testing!

						Good Unit tests do not rely in **implementation details** of the component.

						A test should not break on a refactor, that is, when we change its internal implementation without changing its behavior
					</section>

					<section data-markdown="">
						#### Inputs to the Components

						- **User Interactions**:	Clicking, typing... any "human" interaction
						- **Props**: The arguments a component receives
						- **Data**:	Data incoming from API calls or other sources

						Should all be tested
					</section>
					<section data-markdown="">
						#### Outputs of the Components

						- **DOM elements**:	Any node rendered to the document
						- **Events Emitted** by the component
						- **Side Effects**:	Such as API calls or errors

						Should all be tested
					</section>
					<section data-markdown="">
						Example: Unit Testing [this Component](https://github.com/danii-nebot/HS-unit-test-assignment/blob/main/src/components/level0/Counter.vue)

						Can you spot what's wrong with this test?

						```
							import { mount } from '@vue/test-utils'
							import Counter from './Counter.vue'

							test('counter text updates', async () => {
								const wrapper = mount(Counter)
								const paragraph = wrapper.find('.paragraph')

								expect(paragraph.text()).toBe('Times clicked: 0')

								await wrapper.setData({ count: 2 })

								expect(paragraph.text()).toBe('Times clicked: 2')
							})
						```
					</section>

        </section>
				<section>
					<section data-markdown="">
						### Test Driven Development (TDD)

						Is a software development approach in which unit test cases are
						written first to specify and validate what the code will do, **before** writing the code.

						The Unit tests thus act as both **Documentation** for the code, and **Acceptance Criteria** for the task.

						The core idea is to start with the simplest scenario, write a failing test,
						make the test pass, then move to the next, in an
						**iterative process**.
					</section>

					<section>
						<img src="https://marsner.com/wp-content/uploads/test-driven-development-TDD.png" />
					</section>

					<section data-markdown="">
						#### Exercise: TDD in Action

						Go to Level 0.5 of [**today's Assignment: Unit Tests & TDD**](https://github.com/danii-nebot/HS-unit-test-assignment)!
					</section>
				</section>

				<section>
					<section data-markdown="">
						### Advanced Testing tools

						It is very important that the functionality of each component is tested in
						**isolation**.

						At the same time, all inputs and outputs should be tested.


						To solve this, testing libraries provide with more advance tools: **Spies, Mocks, and Stubs**
					</section>

					<section data-markdown="">
						### Spies

						Sometimes all you need is to validate whether or not a specific function has been called
						- and maybe which arguments were passed.

						This is the task for a spy üïµÔ∏è

					</section>
					<section data-markdown="">
						#### Spies in action

						```
						const fetchSpy = vi.spyOn(global, 'fetch');
						mount(MyComponentAsyncData);

						expect(fetchSpy).toBeCalledTimes(1);
						expect(fetchSpy).toBeCalledWith(myApiUrl)
						```
					</section>
					<section data-markdown="">
						### Mocks

						Spies also offer us the possibility to add a *mock* implementation of the function, replacing its normal behavior.

						We use this to test how our component behaves with different results without needing to run the actual function - in isolation!
					</section>

					<section data-markdown="">
						#### Mocks in action

						```
						const getDetailsSpy = vi.spyOn(userUtils, 'getDetails')
							.mockImplementation((id) => {
								if (id === 1) return 'Boaty McBoatface'
							});

						const wrapper = mount(UserDetailsComponent, {
							props: { userId: 1 }
						});
						expect(wrapper.text()).toContain('McBoatface')
						```
					</section>

					<section data-markdown="">
						#### Mocks in action/2

						Sometimes it is simpler to just provide the output of the function:
						a **returned** value, or in the case of *async* function, a **resolved/rejected** value.

						```
						const getDetailsSpy = vi.spyOn(userUtils, 'getDetails')
							.mockReturnedValue('Boaty McBoatface');

						const fetchSpy = vi.spyOn(apiUtils, 'getUsers')
							.mockResolvedValue({ data: [] });

						const fetchSpy = vi.spyOn(global, 'getUsers')
							.mockRejectedValue('test error');

						```

					</section>

					<section data-markdown="">
						### Stubs

						A **stub** is a dummy component that will replace the implementation of a custom component
						with one that doesn't do anything at all.

						We can use this to simplify testing of components **high in the component hierarchy tree**
						(having one or multiple child components)
					</section>
					<section data-markdown="">
						#### Stubs in action
						```
						const wrapper = mount(App, {
							global: {
								stubs: {
									Child1: true,
									Child2: true,
								},
							},
						});
						// test...
						```
					</section>

					<section data-markdown="">
						#### shallowMount

						This is such a common scenario that Vue Test Utils offers us this
						alternative to mount: *shallowMount*, which will automatically stub all children of the component.

						```
							const wrapper = shallowMount(App);
						```

						As always, check the [docs for more details](https://test-utils.vuejs.org/guide/advanced/stubs-shallow-mount.html)!
					</section>
					<section data-markdown="">
						#### Other utilities: vm

						Vue Test Utils exposes the Vue instance of the component as **vm**, so we can access
						methods and properties from the component, for example **$emit** to simulate events triggered!
					</section>

					<section data-markdown="">
						#### Other utilities: flushPromises

						When working with async data, *flushPromises* is necessary to make sure async operations
						such as promises or DOM updates have happened before asserting against them.
					</section>

					<section data-markdown="">
						#### Practice: Unit testing with loading asynchronous data

						Go to Level 1 of [**today's Assignment: Unit Tests & TDD**](https://github.com/danii-nebot/HS-unit-test-assignment)!

					</section>

				</section>
		</div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/zoom/zoom.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/search/search.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script>
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight ]
			});

		</script>

	</body>
</html>
